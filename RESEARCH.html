<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SAGA RP Agent Proxy v3.0 — 구조 제안</title>

</head>
<body>
<div style="max-width:780px;margin:0 auto;padding:40px 24px 80px;background:#ffffff;color:#1f2328;font-family:'Segoe UI',sans-serif;font-size:15px;line-height:1.85;">

<!-- ═══════════ 헤더 ═══════════ -->
<div style="margin-bottom:36px;padding-bottom:32px;border-bottom:1px solid #d0d7de;">
  <h1 style="font-size:26px;font-weight:800;color:#1f2328;line-height:1.45;margin-bottom:12px;">구조 제안 — RP 장기 세션의 상태 유실 문제를 프록시로 풀어보기</h1>
  <span style="display:inline-block;font-family:monospace;font-size:13px;font-weight:500;color:#0969da;background:#f6f8fa;padding:5px 14px;border-radius:4px;">SAGA RP Agent Proxy v3.0 — Stateful Graph RAG 기반 Context Engineering</span>
</div>

<!-- ═══════════ 인트로 인용 ═══════════ -->
<div style="background:#f6f8fa;border-left:3px solid #d0d7de;padding:20px 24px;margin:28px 0 36px;border-radius:0 8px 8px 0;font-size:14px;color:#656d76;line-height:1.9;">
  단순 캐릭터챗 AI에서 Mem0, Langmem, Letta 같은 Stateful Agent는 과한 구조였습니다.<br>
  하지만 RP는 다릅니다 — 위치, NPC, 아이템, 관계, 세력 등 동적인 요소가 훨씬 많고,<br>
  유저가 직접 세계를 설계하고 만들어 나갑니다.<br>
  코히바블랙님의 연구일지<sup>[1]</sup>를 읽으며 이 가능성을 확인했고,<br>
  <strong>Letta의 판단력을 매 턴이 아닌 필요한 순간에만 쓰면 어떨까</strong> — 여기서 출발했습니다.<br>
  Letta를 핵심에 두되, 프록시 기반 1회 호출 + 비동기 추출로 풀어본 기록입니다.
</div>

<!-- ═══════════ 목차 ═══════════ -->
<div style="background:#f6f8fa;border:1px solid #d0d7de;border-radius:10px;padding:24px 28px;margin:0 0 40px;">
  <div style="font-size:13px;font-weight:700;color:#656d76;text-transform:uppercase;letter-spacing:1.5px;margin-bottom:14px;">목차</div>
  <ol>
    <li><a href="#s1" style="color:#0969da;text-decoration:none;">우리 모두가 겪는 문제</a></li>
    <li><a href="#s2" style="color:#0969da;text-decoration:none;">기존 접근들의 한계</a></li>
    <li><a href="#s3" style="color:#0969da;text-decoration:none;">Letta의 Step Loop — Stateful Agent의 구조</a></li>
    <li><a href="#s4" style="color:#0969da;text-decoration:none;">SAGA의 아이디어: "에이전트는 큐레이션만"</a></li>
    <li><a href="#s5" style="color:#0969da;text-decoration:none;">어떻게 동작하는가</a></li>
    <li><a href="#s6" style="color:#0969da;text-decoration:none;">3-Agent 파이프라인 상세</a></li>
    <li><a href="#s7" style="color:#0969da;text-decoration:none;">다이나믹 로어북 — 정적 로어북의 진화</a></li>
    <li><a href="#s8" style="color:#0969da;text-decoration:none;">비용과 트레이드오프</a></li>
    <li><a href="#s9" style="color:#0969da;text-decoration:none;">코히바블랙님 및 선행 연구자분들께</a></li>
    <li><a href="#s10" style="color:#0969da;text-decoration:none;">만들면서 느낀 것</a></li>
    <li><a href="#s11" style="color:#0969da;text-decoration:none;">참고 자료</a></li>
  </ol>
</div>

<!-- ═══════════ 1. 우리 모두가 겪는 문제 ═══════════ -->
<hr style="border:none;height:1px;background:#d0d7de;margin:40px 0;">
<div style="margin-bottom:48px;" id="s1">
  <h2 style="font-size:22px;font-weight:800;color:#1f2328;margin-bottom:20px;padding-bottom:10px;border-bottom:2px solid #0969da;"><span style="font-family:monospace;font-size:14px;font-weight:600;color:#0969da;margin-right:6px;">01.</span> 우리 모두가 겪는 문제</h2>
  <p>RP를 해본 사람이라면 이런 경험이 있을 겁니다.</p>
  <blockquote style="background:#f6f8fa;border-left:3px solid #d0d7de;padding:14px 20px;margin:16px 0;border-radius:0 6px 6px 0;font-size:14px;color:#656d76;line-height:1.85;">
    <p>30턴 전에 죽인 NPC가 아무렇지 않게 다시 등장한다.</p>
    <p>버린 아이템이 인벤토리에 여전히 있다.</p>
    <p>동쪽으로 이동했는데 서쪽 마을에서 대화가 이어진다.</p>
    <p>HP가 0인데 전투를 계속한다.</p>
  </blockquote>
  <p>장기 RP 세션의 근본적인 문제는 <strong>상태 유실</strong>입니다. LLM은 대화가 길어지면 이전 상태를 잊어버립니다. 컨텍스트 창을 128K, 200K로 늘려도 본질은 같습니다 — 50턴 전 세부사항을 정확히 기억하리라는 보장이 없고, 비용만 선형으로 증가합니다.</p>
  <p>그리고 또 하나의 문제: <strong>로어북은 정적</strong>입니다. "에르겐은 마을 광장의 약초상이다"라고 작성해 두면, 에르겐이 숲으로 이동하거나 사망하더라도 로어북은 변하지 않습니다. LLM은 오래된 설정을 보고 모순된 이야기를 만들게 됩니다.</p>
</div>

<!-- ═══════════ 2. 기존 접근들의 한계 ═══════════ -->
<hr style="border:none;height:1px;background:#d0d7de;margin:40px 0;">
<div style="margin-bottom:48px;" id="s2">
  <h2 style="font-size:22px;font-weight:800;color:#1f2328;margin-bottom:20px;padding-bottom:10px;border-bottom:2px solid #0969da;"><span style="font-family:monospace;font-size:14px;font-weight:600;color:#0969da;margin-right:6px;">02.</span> 기존 접근들의 한계</h2>
  <p>이 문제를 풀려는 시도는 여러 가지가 있었습니다.</p>
  <div style="overflow-x:auto;margin:16px 0;border-radius:8px;border:1px solid #d0d7de;">
    <table style="width:100%;border-collapse:collapse;font-size:13.5px;">
      <thead style="background:#f6f8fa;">
        <tr><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">접근 방식</th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">상태 추적</th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">구조화</th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">유저 지연</th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">비용</th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">한계</th></tr>
      </thead>
      <tbody>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>정적 로어북</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">✕</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">✕</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">없음</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">낮음</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">세계가 변해도 로어북은 고정</td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>전체 히스토리 전송</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">암묵적</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">✕</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">없음</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">높음</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">토큰 낭비 + 장기 세션에서 누적 모순</td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>HypaMemory 계열</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">대화 기억</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">✕</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">낮음</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">중간</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">요약 기반 압축 — 구조화된 상태 추적 불가</td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>Mem0 계열</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">대화 기억</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">✕</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;"><span style="color:#bc4c00;font-weight:500;">높음</span></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">중간</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">매 턴 메모리 추출/갱신이 동기적 → 응답 지연</td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong style="color:#0969da;font-weight:700;">SAGA (이 프로젝트)</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;"><span style="color:#1a7f37;font-weight:500;">○</span></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;"><span style="color:#1a7f37;font-weight:500;">○</span></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;"><span style="color:#1a7f37;font-weight:500;">낮음</span></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">중간</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">추출 정확도가 State Block 품질에 의존</td></tr>
      </tbody>
    </table>
  </div>
  <p><strong>HypaMemory 계열</strong>(RisuAI HypaMemory/SupaMemory, SillyTavern Summarize 등)은 토큰 한계에 도달하면 대화를 요약·압축하여 장기 기억을 시뮬레이션합니다. 대화의 흐름은 기억하지만, "캐릭터가 어디에 있는지", "HP가 얼마인지", "누구와 어떤 관계인지"를 <strong>구조화된 형태로</strong> 추적하지는 못합니다. 요약 과정에서 세부 상태가 소실되므로, 장기 세션의 모순까지 막기엔 부족합니다.</p>
  <p><strong>Mem0 계열</strong>은 LLM이 직접 메모리를 관리하지는 않지만, 매 대화마다 메모리 추출과 갱신이 동기적으로 실행되어 응답 경로에 지연이 발생합니다. 구조화된 상태 추적도 지원하지 않습니다.</p>
</div>

<!-- ═══════════ 3. Letta의 Step Loop ═══════════ -->
<hr style="border:none;height:1px;background:#d0d7de;margin:40px 0;">
<div style="margin-bottom:48px;" id="s3">
  <h2 style="font-size:22px;font-weight:800;color:#1f2328;margin-bottom:20px;padding-bottom:10px;border-bottom:2px solid #0969da;"><span style="font-family:monospace;font-size:14px;font-weight:600;color:#0969da;margin-right:6px;">03.</span> Letta의 Step Loop — Stateful Agent의 구조</h2>
  <p>코히바블랙님이 선행연구<sup>[1]</sup>에서 언급하셨듯, Letta(MemGPT)<sup>[2]</sup>는 LLM에 가상 메모리 계층을 부여하여 <strong>진짜 Stateful Agent</strong>를 만드는 프레임워크입니다. 에이전트가 자신의 Memory Block을 직접 읽고 편집하면서 상태를 유지합니다.</p>
  <p>핵심은 <strong>Step Loop</strong> 구조입니다. 에이전트가 한 턴에 여러 단계를 밟으며, 각 단계에서 "무엇을 읽을지", "어떻게 수정할지"를 LLM이 판단합니다:</p>
  <pre style="background:#f6f8fa;border:1px solid #d0d7de;border-radius:8px;padding:20px;overflow-x:auto;margin:16px 0;font-family:monospace;font-size:12.5px;line-height:1.7;color:#1f2328;white-space:pre;"><code>유저: "마을 광장을 둘러본다"

<span style="color:#1a7f37">[Step 1]</span> 내면 사고 → "기억을 확인해야겠다"       ← LLM 호출
<span style="color:#1a7f37">[Step 2]</span> memory_read(core_memory)              ← 도구 실행
<span style="color:#1a7f37">[Step 3]</span> 내면 사고 → "위치가 바뀌었으니 수정"     ← LLM 호출
<span style="color:#1a7f37">[Step 4]</span> memory_edit(core_memory, location=...) ← 도구 실행
<span style="color:#1a7f37">[Step 5]</span> 내면 사고 → "archival도 확인"           ← LLM 호출
<span style="color:#1a7f37">[Step 6]</span> archival_search("마을 광장")            ← 도구 실행
<span style="color:#1a7f37">[Step 7]</span> 내면 사고 → "응답 생성"                 ← LLM 호출
<span style="color:#1a7f37">[Step 8]</span> send_message("마을 광장은...")          ← 최종 응답

= <span style="color:#bc4c00;font-weight:600">4회 LLM 호출</span></code></pre>
  <p>이 구조의 강점은 <strong>유연성</strong>입니다. 에이전트가 매 턴 상황을 판단하고, 필요한 기억만 선택적으로 읽고, 적절하게 편집합니다. 예상치 못한 상황에도 에이전트가 스스로 대응할 수 있습니다.</p>
  <p>대신 <strong>메모리 읽기/쓰기 자체가 LLM 호출</strong>이므로, 턴당 3~5회의 호출이 발생합니다. 이게 Stateful의 대가입니다 — 생각하고, 도구 쓰고, 또 생각하는 과정이 매 턴 반복됩니다.</p>
  <p>SAGA는 이 Letta의 Step Loop를 핵심에 활용하되, <strong>"매 턴 다회 호출"을 "N턴마다 비동기"로 재배치</strong>하는 아이디어에서 출발했습니다.</p>
</div>

<!-- ═══════════ 4. SAGA의 아이디어 ═══════════ -->
<hr style="border:none;height:1px;background:#d0d7de;margin:40px 0;">
<div style="margin-bottom:48px;" id="s4">
  <h2 style="font-size:22px;font-weight:800;color:#1f2328;margin-bottom:20px;padding-bottom:10px;border-bottom:2px solid #0969da;"><span style="font-family:monospace;font-size:14px;font-weight:600;color:#0969da;margin-right:6px;">04.</span> SAGA의 아이디어: "에이전트는 큐레이션만"</h2>

  <h3 style="font-size:17px;font-weight:700;color:#bc4c00;margin:28px 0 12px;">코딩 에이전트에서 얻은 힌트</h3>
  <p>혹시 Claude Code, OpenClaw, oh-my-claudecode(OMC) 같은 코딩 에이전트를 써보셨나요? 이 도구들은 멀티 에이전트 오케스트레이션, 복잡한 워크플로우 관리, 스킬 체이닝 등을 잘 해냅니다. 그런데 실제로 써보면 의외의 지점을 발견합니다 — 컨텍스트 관리의 핵심은 정교한 메모리 시스템이 아니라 <strong>.md 형식의 구조화된 문서</strong>였습니다. 이 에이전트들은 장기 작업 중에 핵심 정보를 <strong>Notepad/NOTE</strong> 형태로 자기관리합니다. 에이전트가 "무엇이 중요한지" 스스로 판단하여 메모를 갱신하는 패턴입니다.</p>
  <p>여기서 한 가지 더 중요한 점이 있습니다. 이 도구들은 <strong>모든 것을 직접 만들지 않습니다.</strong> Claude Code는 Bash, grep, git 같은 기존 도구를 오케스트레이션하고, OMC는 여러 에이전트를 조율하며, OpenClaw는 기존 LLM API를 게이트웨이로 중계합니다. 핵심은 <strong>이미 잘 만들어진 것들을 어떻게 연결하고 관리하느냐</strong>입니다.</p>
  <p>SAGA도 같은 철학입니다. Letta(Stateful Agent), ChromaDB(벡터 검색), Kuzu(그래프 DB), SQLite(KV 저장소) — 각각은 이미 검증된 도구입니다. SAGA가 하는 건 이것들을 <strong>RP에 맞는 하나의 파이프라인으로 엮고, 언제 무엇을 호출할지 관리하는 오케스트레이션</strong>입니다. 새로운 DB나 메모리 시스템을 만드는 게 아닙니다.</p>
  <p>이걸 RP에 적용할 때 핵심 질문은 이것이었습니다:</p>
  <blockquote style="background:#f6f8fa;border-left:3px solid #d0d7de;padding:14px 20px;margin:16px 0;border-radius:0 6px 6px 0;font-size:14px;color:#656d76;line-height:1.85;">
    <p><strong>에이전트의 판단력이 정말 필요한 곳은 어디인가?</strong></p>
  </blockquote>
  <p>생각해 보면:</p>
  <ul>
    <li><strong>매 턴 상태 추출</strong> — "위치가 바뀌었는가? HP가 변했는가?" → 정규식이나 저비용 LLM으로 충분합니다. 에이전트가 고민할 필요 없습니다.</li>
    <li><strong>매 턴 컨텍스트 조립</strong> — "어떤 로어북이 관련 있는가?" → 점수 기반 필터링으로 충분합니다.</li>
    <li><strong>N턴마다 서사 큐레이션</strong> — "이 모순은 의도된 것인가? 이 복선은 회수해야 하는가?" → <span style="color:#bc4c00;font-weight:500;">여기서만 에이전트의 판단력이 필수입니다.</span> 이전 큐레이션 결정을 기억하고 일관되게 이어가야 합니다.</li>
  </ul>

  <h3 style="font-size:17px;font-weight:700;color:#bc4c00;margin:28px 0 12px;">.md — 에이전트 메모리의 사실상 표준</h3>
  <p>그런데 이런 컨텍스트 관리 패턴을 들여다보면, 공통점이 있습니다. 아키텍처는 전부 다른데, <strong>최종 형식은 다 마크다운</strong>입니다.</p>
  <div style="overflow-x:auto;margin:16px 0;border-radius:8px;border:1px solid #d0d7de;">
    <table style="width:100%;border-collapse:collapse;font-size:13.5px;">
      <thead style="background:#f6f8fa;">
        <tr><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">시스템</th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">아키텍처</th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">컨텍스트 관리</th></tr>
      </thead>
      <tbody>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>Claude Code</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">CLI 에이전트</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><code>CLAUDE.md</code>, <code style="background:#f6f8fa;padding:2px 6px;border-radius:3px;color:#0969da;font-family:monospace;font-size:13px;">~/.claude/memory/*.md</code></td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>OMC</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">오케스트레이터</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><code>notepad.md</code>, <code style="background:#f6f8fa;padding:2px 6px;border-radius:3px;color:#0969da;font-family:monospace;font-size:13px;">AGENTS.md</code>, <code style="background:#f6f8fa;padding:2px 6px;border-radius:3px;color:#0969da;font-family:monospace;font-size:13px;">.omc/plans/*.md</code></td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>OpenClaw</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">Gateway/프록시</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><code>.md</code> 기반 컨텍스트 주입</td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>Codex</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">CLI 에이전트</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><code>AGENTS.md</code>, 마크다운 기반 지시</td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>Letta Code</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">에이전트 프레임워크</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><code>memory/*.md</code> + YAML frontmatter (MemFS)<sup>[3]</sup></td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong style="color:#0969da;font-weight:700;">SAGA</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">Gateway/프록시</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><code>state.md</code>, <code style="background:#f6f8fa;padding:2px 6px;border-radius:3px;color:#0969da;font-family:monospace;font-size:13px;">relations.md</code>, <code style="background:#f6f8fa;padding:2px 6px;border-radius:3px;color:#0969da;font-family:monospace;font-size:13px;">story.md</code>, <code style="background:#f6f8fa;padding:2px 6px;border-radius:3px;color:#0969da;font-family:monospace;font-size:13px;">lore.md</code></td></tr>
      </tbody>
    </table>
  </div>
  <p>Swarm이든, Orchestrator든, Skill 시스템이든 — 상위 구조는 다 달라도 에이전트에게 컨텍스트를 전달하는 최종 형식은 마크다운으로 수렴하고 있습니다. 왜일까요?</p>
  <ul>
    <li><strong>LLM이 가장 잘 읽는 형식</strong>: 학습 데이터에 마크다운이 압도적으로 많음</li>
    <li><strong>구조화와 가독성의 균형</strong>: JSON은 기계적이고 자연어는 비구조적인데, 마크다운은 헤딩/리스트/테이블로 반구조화 가능</li>
    <li><strong>YAML frontmatter로 메타데이터 분리</strong>: 본문은 LLM이 읽고, 프론트매터는 코드가 읽음</li>
    <li><strong>diff/캐싱 친화적</strong>: 텍스트 기반이라 git diff, Prompt Caching 모두 효율적</li>
  </ul>
  <p>SAGA의 .md 캐시 4파일은 이 흐름을 RP에 적용한 것이고, 그 중에서도 Letta Code의 MemFS가 가장 직접적인 참고점이었습니다.</p>

  <h3 style="font-size:17px;font-weight:700;color:#bc4c00;margin:28px 0 12px;">그래서 Letta는 Curator 전담으로</h3>
  <p>Letta의 Step Loop가 강력한 건 맞지만, 매 턴 돌리기엔 비용이 큽니다. 그렇다면 <strong>Letta를 매 턴이 아닌, 서사 큐레이션에만 집중시키자</strong> — 여기서 SAGA가 시작됩니다.</p>
  <p>Curator는 Letta SDK로 생성된 에이전트가 Memory Block(<code style="background:#f6f8fa;padding:2px 6px;border-radius:3px;color:#0969da;font-family:monospace;font-size:13px;">narrative_memory</code>)을 자기편집하면서 서사 판단의 연속성을 유지합니다. 10턴 전에 "이 모순은 의도된 전개"라고 기록해 두면, 20턴 후에도 그 판단을 이어갈 수 있습니다. 이건 Letta의 Memory Block 없이는 불가능합니다.</p>
  <p>그리고 Letta가 최근 진화시킨 <strong>MemFS(Memory File System)</strong><sup>[3]</sup> 구조도 알고 있었습니다. Letta Code는 에이전트 메모리를 <strong>마크다운 파일 시스템</strong>으로 관리합니다:</p>
  <pre style="background:#f6f8fa;border:1px solid #d0d7de;border-radius:8px;padding:20px;overflow-x:auto;margin:16px 0;font-family:monospace;font-size:12.5px;line-height:1.7;color:#1f2328;white-space:pre;"><code>memory/
  project_overview.md      ← YAML frontmatter + 마크다운 본문
  architecture_notes.md
  current_tasks.md
  ...</code></pre>
  <p>각 파일에 YAML frontmatter가 붙고, 에이전트가 <code style="background:#f6f8fa;padding:2px 6px;border-radius:3px;color:#0969da;font-family:monospace;font-size:13px;">create_file</code>, <code style="background:#f6f8fa;padding:2px 6px;border-radius:3px;color:#0969da;font-family:monospace;font-size:13px;">modify_file</code> 같은 도구로 자기편집합니다. git이 버전 관리를 담당합니다.</p>
  <p>SAGA의 <strong>.md 캐시 4파일</strong> 설계는 이 구조에서 직접 영향을 받았습니다:</p>
  <div style="overflow-x:auto;margin:16px 0;border-radius:8px;border:1px solid #d0d7de;">
    <table style="width:100%;border-collapse:collapse;font-size:13.5px;">
      <thead style="background:#f6f8fa;">
        <tr><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;"></th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">Letta MemFS</th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">SAGA .md 캐시</th></tr>
      </thead>
      <tbody>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>형식</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">마크다운 + YAML frontmatter</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">마크다운 + YAML frontmatter</td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>파일 구조</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><code>memory/project_overview.md</code> 등</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><code>state.md</code>, <code style="background:#f6f8fa;padding:2px 6px;border-radius:3px;color:#0969da;font-family:monospace;font-size:13px;">relations.md</code>, <code style="background:#f6f8fa;padding:2px 6px;border-radius:3px;color:#0969da;font-family:monospace;font-size:13px;">story.md</code>, <code style="background:#f6f8fa;padding:2px 6px;border-radius:3px;color:#0969da;font-family:monospace;font-size:13px;">lore.md</code></td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>버전 관리</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">git (커밋 기반)</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">YAML frontmatter의 <code style="background:#f6f8fa;padding:2px 6px;border-radius:3px;color:#0969da;font-family:monospace;font-size:13px;">updated_at</code>, <code style="background:#f6f8fa;padding:2px 6px;border-radius:3px;color:#0969da;font-family:monospace;font-size:13px;">turn</code> 필드</td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>편집 주체</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><span style="color:#bc4c00;font-weight:500;">에이전트</span> (<code style="background:#f6f8fa;padding:2px 6px;border-radius:3px;color:#0969da;font-family:monospace;font-size:13px;">modify_file</code> 도구)</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><span style="color:#1a7f37;font-weight:500;">코드</span> (정규식 파싱 → <code style="background:#f6f8fa;padding:2px 6px;border-radius:3px;color:#0969da;font-family:monospace;font-size:13px;">os.replace()</code> 원자적 교체)</td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>편집 비용</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">LLM 호출 필요</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">LLM 호출 불필요</td></tr>
      </tbody>
    </table>
  </div>
  <p>차이는 <strong>"누가 편집하는가"</strong> 입니다. Letta MemFS는 에이전트가 파일을 읽고 판단하고 편집합니다. SAGA는 같은 구조를 쓰되, <strong>매 턴 편집은 코드 로직(Sub-B)에게 위임</strong>합니다. 대신 <strong>N턴마다 Letta Curator가 .md 캐시를 큐레이션</strong>합니다 — story.md 압축, 모순 수정 등.</p>
  <blockquote style="background:#f6f8fa;border-left:3px solid #d0d7de;padding:14px 20px;margin:16px 0;border-radius:0 6px 6px 0;font-size:14px;color:#656d76;line-height:1.85;">
    <p>정리하면: Letta의 Memory Block은 Curator의 두뇌이고,<br>
    Letta의 MemFS 패턴은 .md 캐시의 설계 원형입니다.<br>
    SAGA가 바꾼 건 <strong>"매 턴 편집을 에이전트가 아닌 코드가 한다"</strong> 는 것뿐입니다.</p>
  </blockquote>

  <h3 style="font-size:17px;font-weight:700;color:#bc4c00;margin:28px 0 12px;">그래서 이렇게 분리했습니다</h3>
  <pre style="background:#f6f8fa;border:1px solid #d0d7de;border-radius:8px;padding:20px;overflow-x:auto;margin:16px 0;font-family:monospace;font-size:12.5px;line-height:1.7;color:#1f2328;white-space:pre;"><code>┌─────────────────────────────────────────────────────┐
│  메인 루프 (매 턴, 유저 대기)                         │
│                                                     │
│  Sub-A: DB 검색 + 프롬프트 조립   ← 코드 로직, LLM 0회  │
│  LLM: 내레이션 1회 호출            ← <span style="color:#bc4c00">이것만 유저 대기</span>    │
│  Sub-B: 상태 추출 + DB 갱신       ← 비동기, 유저 무관   │
└─────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────┐
│  Curator (10턴마다, 비동기)                           │
│                                                     │
│  Letta Memory Block 자기편집      ← 에이전트 판단 필요  │
│  모순 탐지, 서사 압축, 이벤트 관리   ← 다회 호출 OK     │
│                                    (유저 대기 아님)    │
└─────────────────────────────────────────────────────┘</code></pre>
  <p>코딩 에이전트가 Notepad를 통해 작업 맥락을 자기관리하듯, <strong>Letta Curator는 Memory Block을 통해 큐레이션 판단 이력을 자기관리</strong>합니다. 단, 이 과정은 10턴마다 비동기로만 일어나므로 유저가 기다릴 일이 없습니다.</p>
</div>

<!-- ═══════════ 5. 어떻게 동작하는가 ═══════════ -->
<hr style="border:none;height:1px;background:#d0d7de;margin:40px 0;">
<div style="margin-bottom:48px;" id="s5">
  <h2 style="font-size:22px;font-weight:800;color:#1f2328;margin-bottom:20px;padding-bottom:10px;border-bottom:2px solid #0969da;"><span style="font-family:monospace;font-size:14px;font-weight:600;color:#0969da;margin-right:6px;">05.</span> 어떻게 동작하는가</h2>
  <p>SAGA는 <strong>OpenAI-compatible 프록시</strong>입니다. 클라이언트(RisuAI, SillyTavern 등)와 LLM 사이에 끼어서, 프론트엔드 수정 없이 동작합니다. API Base URL만 바꾸면 됩니다.</p>

  <h3 style="font-size:17px;font-weight:700;color:#bc4c00;margin:28px 0 12px;">Read-Write 순환</h3>
  <p>매 턴은 읽기(READ)와 쓰기(WRITE)의 순환입니다:</p>
  <pre style="background:#f6f8fa;border:1px solid #d0d7de;border-radius:8px;padding:20px;overflow-x:auto;margin:16px 0;font-family:monospace;font-size:12.5px;line-height:1.7;color:#1f2328;white-space:pre;"><code>                    ┌──────────────────────────────┐
                    │        3계층 DB 저장소          │
                    │  Kuzu(그래프) + ChromaDB(벡터)  │
                    │      + SQLite(상태 KV)         │
                    └──────┬───────────────┬────────┘
                   READ    │               │  WRITE
                (동기 ~35ms)│               │(비동기)
                           ▼               │
    ┌────────┐    ┌────────────────┐    ┌──┴──────────────┐
    │ Client │───▶│  Sub-A:        │───▶│  LLM (1회 호출)   │
    │        │◀───│  Context Build │◀───│                  │
    └────────┘    └────────────────┘    └──┬──────────────┘
                                           │ 응답 반환 후
                                           ▼
                                    ┌──────────────┐
                                    │  Sub-B:      │
                                    │  추출 + 갱신  │──▶ DB WRITE
                                    └──────────────┘</code></pre>
  <p><span style="display:inline-block;font-family:monospace;font-size:11px;font-weight:600;color:#fff;background:#0969da;width:22px;height:22px;line-height:22px;text-align:center;border-radius:50%;margin-right:8px;">1</span><strong>READ</strong> (동기, ~35ms): Sub-A가 3계층 DB에서 현재 상태, 관련 로어북, 그래프 연결을 검색 → 프롬프트에 주입</p>
  <p><span style="display:inline-block;font-family:monospace;font-size:11px;font-weight:600;color:#fff;background:#0969da;width:22px;height:22px;line-height:22px;text-align:center;border-radius:50%;margin-right:8px;">2</span>LLM 1회 호출 → 유저에게 응답 반환</p>
  <p><span style="display:inline-block;font-family:monospace;font-size:11px;font-weight:600;color:#fff;background:#0969da;width:22px;height:22px;line-height:22px;text-align:center;border-radius:50%;margin-right:8px;">3</span><strong>WRITE</strong> (비동기, 유저 대기 없음): Sub-B가 응답에서 상태 변화를 추출 → 3계층 DB 갱신</p>
  <p>이 순환이 매 턴 반복되므로, DB는 항상 최신 세계 상태를 반영합니다.</p>

  <h3 style="font-size:17px;font-weight:700;color:#bc4c00;margin:28px 0 12px;">왜 3계층 DB인가?</h3>
  <p>Letta는 에이전트의 메모리를 Core / Archival / Recall 3계층으로 나눕니다. SAGA는 이 구조를 에이전트 호출 없이 코드가 직접 접근하는 3계층 DB로 대체했습니다.</p>
  <div style="overflow-x:auto;margin:16px 0;border-radius:8px;border:1px solid #d0d7de;">
    <table style="width:100%;border-collapse:collapse;font-size:13.5px;">
      <thead style="background:#f6f8fa;">
        <tr><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">Letta 메모리 계층</th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">SAGA DB</th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">역할</th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">예시 쿼리</th></tr>
      </thead>
      <tbody>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>Core Memory</strong> (항상 로드)</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>SQLite</strong> (KV)</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">현재 상태, 세션 메타</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">"플레이어 위치는?"</td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>Archival Memory</strong> (임베딩 검색)</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>ChromaDB</strong> (벡터)</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">로어북, 에피소드 기억</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">"어둠의 숲과 비슷한 장소는?"</td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>Recall Memory</strong> (이력 검색)</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>Kuzu</strong> (그래프)</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">관계, 연결 구조</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">"에르겐이 아는 사람은?"</td></tr>
      </tbody>
    </table>
  </div>
  <p>그리고 이 세 DB 위에 <strong>.md 캐시 4파일</strong>이 있습니다 — <code style="background:#f6f8fa;padding:2px 6px;border-radius:3px;color:#0969da;font-family:monospace;font-size:13px;">state.md</code>, <code style="background:#f6f8fa;padding:2px 6px;border-radius:3px;color:#0969da;font-family:monospace;font-size:13px;">relations.md</code>, <code style="background:#f6f8fa;padding:2px 6px;border-radius:3px;color:#0969da;font-family:monospace;font-size:13px;">story.md</code>, <code style="background:#f6f8fa;padding:2px 6px;border-radius:3px;color:#0969da;font-family:monospace;font-size:13px;">lore.md</code>. 이 파일들은 프롬프트의 캐싱 가능한 프리픽스로 사용되어, Anthropic의 Prompt Caching과 결합하면 비용을 크게 줄입니다.</p>

  <h3 style="font-size:17px;font-weight:700;color:#bc4c00;margin:28px 0 12px;">Kuzu 그래프</h3>
  <p>SAGA는 Kuzu에 5개의 노드와 8개의 엣지를 정의합니다 (예시입니다. 확장할 수 있습니다):</p>
  <div style="overflow-x:auto;margin:16px 0;border-radius:8px;border:1px solid #d0d7de;">
    <table style="width:100%;border-collapse:collapse;font-size:13.5px;">
      <thead style="background:#f6f8fa;">
        <tr><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">시작 노드</th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">엣지</th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">끝 노드</th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">설명</th></tr>
      </thead>
      <tbody>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>Character</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">RELATES_TO</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>Character</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">관계: met, knows, hostile...</td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>Character</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">LOCATED_AT</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>Location</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">캐릭터의 현재 위치</td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>Location</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">ADJACENT</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>Location</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">인접한 장소</td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>Character</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">OWNS</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>Item</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">소유한 아이템</td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>Location</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">HAS_LORE</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>Lore</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">장소에 연결된 로어</td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>Lore</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">RELATED</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>Lore</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">로어 간 연결</td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>Character</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">INVOLVED_IN</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>Event</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">참여한 이벤트</td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>Event</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">CAUSED</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>Event</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">이벤트 인과</td></tr>
      </tbody>
    </table>
  </div>
  <p>"아리아가 어둠의 숲에서 고블린왕 크룩을 만났다"는 것이 그래프에서는:</p>
  <pre style="background:#f6f8fa;border:1px solid #d0d7de;border-radius:8px;padding:20px;overflow-x:auto;margin:16px 0;font-family:monospace;font-size:12.5px;line-height:1.7;color:#1f2328;white-space:pre;"><code>아리아 ──LOCATED_AT──▶ 어둠의 숲
아리아 ──RELATES_TO(met)──▶ 크룩
크룩 ──LOCATED_AT──▶ 어둠의 숲</code></pre>
  <p>으로 표현됩니다. 다음 턴에 "근처에 누가 있지?"라는 질문에 그래프 쿼리로 즉시 답할 수 있습니다.</p>

  <h3 style="font-size:17px;font-weight:700;color:#bc4c00;margin:28px 0 12px;">Graph RAG: 벡터만으로는 부족하다</h3>
  <p>ChromaDB 벡터 검색만으로는 "에르겐이 알고 있는 것" 같은 관계 기반 질의에 취약합니다<sup>[2]</sup>. 그래서 <strong>하이브리드 리랭킹</strong>을 씁니다:</p>
  <pre style="background:#f6f8fa;border:1px solid #d0d7de;border-radius:8px;padding:20px;overflow-x:auto;margin:16px 0;font-family:monospace;font-size:12.5px;line-height:1.7;color:#1f2328;white-space:pre;"><code>ChromaDB 벡터 검색: "어둠의 숲" → [어둠의 숲, 고블린왕 크룩, ...]
                                          │
Kuzu N-hop 확장 (2단계):                   ▼
    어둠의 숲 ──ADJACENT──▶ 마을 광장
    어둠의 숲 ──HAS_LORE──▶ 대붕괴          ← <span style="color:#bc4c00">벡터만으로는 못 찾는 연결</span>
    크룩 ──RELATES_TO──▶ 아리아
                    │
ChromaDB 재검색:    ▼
    [대붕괴, 마을 광장, ...] → 병합 + 중복 제거</code></pre>
  <p>벡터가 "비슷한 것"을 찾아주고, 그래프가 "연결된 것"을 확장해 줍니다.</p>
</div>

<!-- ═══════════ 6. 3-Agent 파이프라인 상세 ═══════════ -->
<hr style="border:none;height:1px;background:#d0d7de;margin:40px 0;">
<div style="margin-bottom:48px;" id="s6">
  <h2 style="font-size:22px;font-weight:800;color:#1f2328;margin-bottom:20px;padding-bottom:10px;border-bottom:2px solid #0969da;"><span style="font-family:monospace;font-size:14px;font-weight:600;color:#0969da;margin-right:6px;">06.</span> 3-Agent 파이프라인 상세</h2>

  <h3 style="font-size:17px;font-weight:700;color:#bc4c00;margin:28px 0 12px;">Sub-A: Context Builder (동기, ~35ms, LLM 호출 없음)</h3>
  <p>유저 요청이 올 때마다 실행됩니다. <strong>LLM을 호출하지 않으므로</strong> 매우 빠릅니다.</p>
  <pre style="background:#f6f8fa;border:1px solid #d0d7de;border-radius:8px;padding:20px;overflow-x:auto;margin:16px 0;font-family:monospace;font-size:12.5px;line-height:1.7;color:#1f2328;white-space:pre;"><code>.md 캐시 읽기 (5ms) → 병렬 DB 조회 (30ms) → 로어북 필터 → 토큰 예산 내 조립
                        │
                        ├─ Kuzu: 플레이어 위치, HP, 인벤토리, 근처 NPC
                        └─ ChromaDB: 유저 입력 기반 벡터 검색 → 그래프 확장 → 리랭킹</code></pre>
  <p>조립된 컨텍스트는 시스템 메시지에 주입됩니다:</p>
  <pre style="background:#f6f8fa;border:1px solid #d0d7de;border-radius:8px;padding:20px;overflow-x:auto;margin:16px 0;font-family:monospace;font-size:12.5px;line-height:1.7;color:#1f2328;white-space:pre;"><code><span style="color:#0969da;font-weight:600">[--- SAGA Dynamic Context ---]</span>
(state.md + relations.md + story.md + lore.md)

<span style="color:#0969da;font-weight:600">[최신 변경]</span>
위치: 어둠의 숲 | HP: 85/100 | 인벤토리: 불꽃 검, 치유 물약

<span style="color:#0969da;font-weight:600">[관련 연결]</span>
어둠의 숲 → 고블린왕 크룩 → 고대 유적

<span style="color:#0969da;font-weight:600">[관련 로어북]</span>
- 어둠의 숲: 에르시아 변방의 위험한 숲...

<span style="color:#0969da;font-weight:600">[--- SAGA State Tracking ---]</span>
응답 마지막에 상태 블록을 추가해주세요: (state block 형식 지시)</code></pre>
  <p><strong>토큰 예산</strong>: 동적 컨텍스트에는 설정 가능한 토큰 예산이 적용됩니다. .md 캐시, 로어북, 그래프 확장, 상태 브리핑, 지시문 각각에 할당량이 있고, 예산 안에서 관련성 높은 정보를 우선 패킹합니다.</p>

  <h3 style="font-size:17px;font-weight:700;color:#bc4c00;margin:28px 0 12px;">Sub-B: Post-Turn Extractor (비동기, 유저 대기 없음)</h3>
  <p>응답이 유저에게 전달된 <strong>뒤에</strong> <code style="background:#f6f8fa;padding:2px 6px;border-radius:3px;color:#0969da;font-family:monospace;font-size:13px;">asyncio.create_task</code>로 백그라운드 실행됩니다.</p>
  <ol>
    <li>LLM 응답에서 <strong>State Block 파싱</strong> (정규식 → 실패 시 경량 LLM으로 폴백 추출)</li>
    <li>Kuzu 그래프 갱신 (위치 이동, NPC 등장, 관계 변화, 아이템 획득/소실, HP 변화)</li>
    <li>SQLite 갱신 (world_state KV, turn_log)</li>
    <li>ChromaDB 에피소드 기록 ("Turn 5 | 어둠의 숲 | 만남: 고블린 족장")</li>
    <li>.md 캐시 원자적 갱신 (.tmp → <code style="background:#f6f8fa;padding:2px 6px;border-radius:3px;color:#0969da;font-family:monospace;font-size:13px;">os.replace()</code> 원자적 교체)</li>
  </ol>
  <p><strong>State Block</strong>은 LLM에게 응답 끝에 출력하도록 요청하는 구조화된 블록입니다:</p>
  <pre style="background:#f6f8fa;border:1px solid #d0d7de;border-radius:8px;padding:20px;margin:16px 0;font-family:monospace;font-size:12.5px;line-height:1.8;white-space:pre;color:#1f2328;">
<span style="color:#bc4c00;">location</span>: <span style="color:#1a7f37;">어둠의 숲</span>
<span style="color:#bc4c00;">location_moved</span>: <span style="color:#1a7f37;">true</span>
<span style="color:#bc4c00;">hp_change</span>: <span style="color:#1a7f37;">-15</span>
<span style="color:#bc4c00;">items_gained</span>: <span style="color:#8250df;">[</span><span style="color:#1a7f37;">불꽃 검</span><span style="color:#8250df;">]</span>
<span style="color:#bc4c00;">npc_met</span>: <span style="color:#8250df;">[</span><span style="color:#1a7f37;">고블린왕 크룩</span><span style="color:#8250df;">]</span>
<span style="color:#bc4c00;">relationship_changes</span>: <span style="color:#8250df;">[{</span><span style="color:#bc4c00;">from</span>: <span style="color:#1a7f37;">아리아</span>, <span style="color:#bc4c00;">to</span>: <span style="color:#1a7f37;">크룩</span>, <span style="color:#bc4c00;">type</span>: <span style="color:#1a7f37;">hostile</span>, <span style="color:#bc4c00;">delta</span>: <span style="color:#1a7f37;">-2</span><span style="color:#8250df;">}]</span>
<span style="color:#bc4c00;">mood</span>: <span style="color:#1a7f37;">tense</span>
  </pre>
  <p>이걸 파싱해서 DB를 갱신합니다. 유저에게는 State Block이 제거된 깨끗한 응답만 전달됩니다.</p>

  <h3 style="font-size:17px;font-weight:700;color:#bc4c00;margin:28px 0 12px;">Curator (10턴마다, 비동기)</h3>
  <p>여기서 <strong>Letta가 등장</strong>합니다.</p>
  <p>Curator는 Letta SDK로 생성된 에이전트가 Memory Block(<code style="background:#f6f8fa;padding:2px 6px;border-radius:3px;color:#0969da;font-family:monospace;font-size:13px;">narrative_memory</code>)을 가지고 동작합니다. 10턴마다 호출되어:</p>
  <ul>
    <li><strong>서사 모순 탐지</strong>: 죽은 NPC가 살아있는지, HP 0인데 생존인지, 위치 불일치가 있는지</li>
    <li><strong>장기 서사 압축</strong>: story.md가 50턴 이상이면 요약 압축</li>
    <li><strong>이벤트 스케줄링</strong>: 복선 회수, 새 이벤트 제안</li>
  </ul>
  <p>핵심은 Letta 에이전트의 <strong>Memory Block이 큐레이션 간에 유지</strong>된다는 것입니다. 10턴 전에 "에르겐 위치 모순 발견"이라고 기록해 두면, 20턴 후 "그 모순은 수정되었는가?"를 이어서 판단할 수 있습니다. Direct LLM 폴백은 이 연속성이 없습니다.</p>
  <p>Letta가 실패하면 Direct LLM으로 자동 폴백하므로, <strong>Letta 없이도 시스템은 동작</strong>합니다 — 다만 큐레이션 판단의 연속성이 떨어집니다.</p>
</div>

<!-- ═══════════ 7. 다이나믹 로어북 ═══════════ -->
<hr style="border:none;height:1px;background:#d0d7de;margin:40px 0;">
<div style="margin-bottom:48px;" id="s7">
  <h2 style="font-size:22px;font-weight:800;color:#1f2328;margin-bottom:20px;padding-bottom:10px;border-bottom:2px solid #0969da;"><span style="font-family:monospace;font-size:14px;font-weight:600;color:#0969da;margin-right:6px;">07.</span> 다이나믹 로어북 — 정적 로어북의 진화</h2>
  <p>전통적 로어북의 최대 문제는 <strong>"한번 작성하면 영원히 고정"</strong> 이라는 점이었습니다. "에르겐은 마을 광장의 약초상이다"라고 적어 두면, 에르겐이 숲으로 도망치든, 죽든, 로어북은 변하지 않습니다. SAGA는 <strong>엔트리 자동 갱신 + 레이어 감쇠 + 점수 기반 필터링</strong>으로 이 문제를 풀었습니다.</p>

  <h3 style="font-size:17px;font-weight:700;color:#bc4c00;margin:28px 0 12px;">엔트리 자동 갱신</h3>
  <p>로어북 엔트리는 Sub-B가 매 턴 자동으로 갱신합니다. State Block에서 상태 변화를 추출한 뒤, 해당 엔트리의 내용과 메타데이터를 함께 업데이트합니다.</p>
  <p>예를 들어, "에르겐이 숲으로 도망쳤다"가 발생하면:</p>
  <pre style="background:#f6f8fa;border:1px solid #d0d7de;border-radius:8px;padding:20px;overflow-x:auto;margin:16px 0;font-family:monospace;font-size:12.5px;line-height:1.7;color:#1f2328;white-space:pre;"><code><span style="color:#bc4c00">[이전]</span> 에르겐 — "마을 광장의 약초상. 조용한 성격."
                 위치: 마을 광장 | 상태: 활성 | 레이어: A2

<span style="color:#1a7f37">[이후]</span> 에르겐 — "약초상. 마을 광장에서 도주하여 현재 어둠의 숲에 은신 중."
                 위치: 어둠의 숲 | 상태: 활성 | 레이어: A2 | last_mentioned: Turn 15</code></pre>
  <p>엔트리 본문은 LLM이 수정하는 게 아니라, Sub-B의 코드 로직이 State Block의 위치/상태 변화를 파싱해서 기계적으로 반영합니다. NPC 사망, 아이템 소실, 장소 상태 변경 등이 모두 이 방식으로 처리됩니다.</p>

  <h3 style="font-size:17px;font-weight:700;color:#bc4c00;margin:28px 0 12px;">레이어 시스템과 감쇠</h3>
  <p>모든 엔트리는 중요도에 따라 4개 레이어 중 하나에 배치됩니다:</p>
  <div style="overflow-x:auto;margin:16px 0;border-radius:8px;border:1px solid #d0d7de;">
    <table style="width:100%;border-collapse:collapse;font-size:13.5px;">
      <thead style="background:#f6f8fa;">
        <tr><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">레이어</th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">감쇠</th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">용도</th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">예시</th></tr>
      </thead>
      <tbody>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong style="color:#0969da">A1</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">없음</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">핵심 세계관, 주요 장소, 역사</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">어둠의 숲, 고대 열쇠, 대붕괴</td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong style="color:#1a7f37">A2</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">없음</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">주요 아이템, 활성 장소</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">마을 광장, 불꽃 검</td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong style="color:#bc4c00">A3</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">7턴</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">세력, 배경 설정</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">은빛 성채, 숲의 결사</td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong style="color:#8250df">A4</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">3턴</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">숨겨진 비밀, 스포일러</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">에르겐의 비밀, 고블린왕의 목적</td></tr>
      </tbody>
    </table>
  </div>
  <p>A1, A2는 항상 활성입니다. A3, A4는 <strong>감쇠 타이머</strong>가 있어서, 일정 턴 동안 대화에서 언급되지 않으면 비활성화됩니다. 대화에서 다시 언급되면 타이머가 리셋됩니다.</p>
  <p>이 구조의 효과:</p>
  <ul>
    <li><strong>핵심 세계관은 항상 참조 가능</strong>: A1/A2는 감쇠 없이 항상 프롬프트에 포함</li>
    <li><strong>토큰 자동 절약</strong>: 한동안 안 쓰는 배경 설정(A3)이나 비밀(A4)은 자동으로 빠짐</li>
    <li><strong>스포일러 방지</strong>: A4 엔트리는 3턴만 유지되므로, 관련 상황에서만 잠깐 등장하고 사라짐</li>
    <li><strong>감쇠 리셋</strong>: 대화에서 "숲의 결사"가 다시 언급되면 A3 타이머가 7턴으로 리셋</li>
  </ul>

  <h3 style="font-size:17px;font-weight:700;color:#bc4c00;margin:28px 0 12px;">필터링 파이프라인</h3>
  <p>레이어 시스템만으로는 "지금 이 턴에 어떤 엔트리를 프롬프트에 넣을지"를 결정할 수 없습니다. SAGA는 벡터 검색 → 게이트 점수 → 감쇠 필터 → 레이어 가중치 → 예산 패킹의 파이프라인을 거칩니다:</p>
  <pre style="background:#f6f8fa;border:1px solid #d0d7de;border-radius:8px;padding:20px;overflow-x:auto;margin:16px 0;font-family:monospace;font-size:12.5px;line-height:1.7;color:#1f2328;white-space:pre;"><code>ChromaDB 벡터 검색 결과 (10개 후보)
    │
    ▼
<span style="color:#0969da">위치 게이트</span>: 플레이어 현재 위치와 관련? → <span style="color:#1a7f37">+3.0점</span>
<span style="color:#0969da">NPC 게이트</span>: 근처 NPC와 관련?          → <span style="color:#1a7f37">+2.0점</span>
<span style="color:#0969da">관계 전파</span>: 알려진 관계에 포함?          → <span style="color:#1a7f37">+1.0점</span>
    │
    ▼
비활성 필터: A4 > 3턴 미언급이면 제외, A3 > 7턴 미언급이면 제외
    │
    ▼
레이어별 가중치: A1 +2.0, A2 +1.5, A3 +0.5, A4 +0.0
    │
    ▼
점수 정렬 → 토큰 예산 내에서 상위 엔트리 선택</code></pre>

  <h3 style="font-size:17px;font-weight:700;color:#bc4c00;margin:28px 0 12px;">구체적 시나리오</h3>
  <p>플레이어가 어둠의 숲에 있고, 직전 턴에 고블린왕 크룩을 만났다고 가정합니다:</p>
  <div style="overflow-x:auto;margin:16px 0;border-radius:8px;border:1px solid #d0d7de;">
    <table style="width:100%;border-collapse:collapse;font-size:13.5px;">
      <thead style="background:#f6f8fa;">
        <tr><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">엔트리</th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">레이어</th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">벡터 유사도</th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">위치 게이트</th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">NPC 게이트</th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">레이어 가중치</th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">총점</th></tr>
      </thead>
      <tbody>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>어둠의 숲</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;"><strong style="color:#0969da">A1</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">0.9</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;"><span style="color:#1a7f37;font-weight:500;">+3.0</span></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">—</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">+2.0</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;"><strong>5.9</strong></td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>고블린왕 크룩</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;"><strong style="color:#1a7f37">A2</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">0.7</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">—</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;"><span style="color:#1a7f37;font-weight:500;">+2.0</span></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">+1.5</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;"><strong>4.2</strong></td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>대붕괴</strong> (어둠의 숲 연관 로어)</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;"><strong style="color:#0969da">A1</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">0.3</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">—</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">—</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">+2.0</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;"><strong>2.3</strong></td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>은빛 성채</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;"><strong style="color:#bc4c00">A3</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">0.1</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">—</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">—</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">+0.5</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;"><strong>0.6</strong></td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong>에르겐의 비밀</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;"><strong style="color:#8250df">A4</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">0.0</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">—</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">—</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">—</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;"><span style="color:#bc4c00;font-weight:500;">제외</span> (4턴 미언급)</td></tr>
      </tbody>
    </table>
  </div>
  <p>어둠의 숲과 고블린왕 크룩이 최상위, 대붕괴가 그래프 확장으로 따라 들어오고, 은빛 성채는 점수가 낮아 토큰 예산에서 밀려납니다. 에르겐의 비밀은 A4인데 4턴째 미언급이라 아예 필터링됩니다.</p>
  <p>이렇게 하면 <strong>지금 이 턴에 정말 필요한 로어북만</strong> 프롬프트에 들어갑니다.</p>
</div>

<!-- ═══════════ 8. 비용과 트레이드오프 ═══════════ -->
<hr style="border:none;height:1px;background:#d0d7de;margin:40px 0;">
<div style="margin-bottom:48px;" id="s8">
  <h2 style="font-size:22px;font-weight:800;color:#1f2328;margin-bottom:20px;padding-bottom:10px;border-bottom:2px solid #0969da;"><span style="font-family:monospace;font-size:14px;font-weight:600;color:#0969da;margin-right:6px;">08.</span> 비용과 트레이드오프</h2>

  <h3 style="font-size:17px;font-weight:700;color:#bc4c00;margin:28px 0 12px;">멀티모델 전략</h3>
  <p>모든 작업에 같은 모델을 쓸 필요는 없습니다:</p>
  <div style="overflow-x:auto;margin:16px 0;border-radius:8px;border:1px solid #d0d7de;">
    <table style="width:100%;border-collapse:collapse;font-size:13.5px;">
      <thead style="background:#f6f8fa;">
        <tr><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">작업</th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">모델</th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">이유</th></tr>
      </thead>
      <tbody>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">내레이션</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">Claude Sonnet 4.5</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">서사 품질이 핵심</td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">상태 추출 (Sub-B)</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">경량 LLM (Gemini Flash 등)</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">구조화된 추출은 저비용 모델로 충분</td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">큐레이션</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">Claude Sonnet 4.5</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">서사 판단 필요하나, 10턴마다만</td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">임베딩</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">text-embedding-3-small</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">범용, 저비용</td></tr>
      </tbody>
    </table>
  </div>

  <h3 style="font-size:17px;font-weight:700;color:#bc4c00;margin:28px 0 12px;">100턴 기준 비용 비교</h3>
  <div style="overflow-x:auto;margin:16px 0;border-radius:8px;border:1px solid #d0d7de;">
    <table style="width:100%;border-collapse:collapse;font-size:13.5px;">
      <thead style="background:#f6f8fa;">
        <tr><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">접근 방식</th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">LLM 호출 횟수</th><th style="padding:12px 16px;text-align:left;font-weight:600;color:#0969da;font-size:12.5px;border-bottom:1px solid #d0d7de;">비고</th></tr>
      </thead>
      <tbody>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">전체 히스토리 전송</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;">100</td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">턴마다 히스토리 누적, 비용 선형 증가</td></tr>
        <tr><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;"><strong style="color:#0969da;font-weight:700;">SAGA</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;text-align:center;"><strong>100 + 100 경량 + 10 Curator</strong></td><td style="padding:10px 16px;border-bottom:1px solid #d0d7de;color:#1f2328;">내레이션 100 + 경량 LLM 추출 100 + 큐레이션 10</td></tr>
      </tbody>
    </table>
  </div>
  <p>SAGA는 고비용 모델(Sonnet)은 내레이션에만, 경량 LLM은 추출에만 사용합니다. 그리고 .md 캐시 + Anthropic Prompt Caching으로 입력 토큰 비용을 추가로 줄입니다.</p>

  <h3 style="font-size:17px;font-weight:700;color:#bc4c00;margin:28px 0 12px;">한계</h3>
  <div style="background:#f6f8fa;border:1px solid #d0d7de;border-left:3px solid #1a7f37;border-radius:8px;padding:20px 24px;margin:16px 0;">
    <p><strong>SAGA가 잘 하는 것:</strong></p>
    <ul>
      <li>구조화된 상태(위치, HP, 인벤토리, NPC 관계) 추적</li>
      <li>프론트엔드 수정 없이 투명한 적용</li>
      <li>유저 체감 지연 최소화 (1회 호출)</li>
      <li><strong>.md 캐시 기반의 확장성</strong>: 새로운 .md 파일을 추가하는 것만으로 추적 영역을 넓힐 수 있음 (예: <code style="background:#f6f8fa;padding:2px 6px;border-radius:3px;color:#0969da;font-family:monospace;font-size:13px;">npc.md</code>, <code style="background:#f6f8fa;padding:2px 6px;border-radius:3px;color:#0969da;font-family:monospace;font-size:13px;">world.md</code>, <code style="background:#f6f8fa;padding:2px 6px;border-radius:3px;color:#0969da;font-family:monospace;font-size:13px;">faction.md</code> 등)</li>
    </ul>
  </div>
  <div style="background:#f6f8fa;border:1px solid #d0d7de;border-left:3px solid #cf222e;border-radius:8px;padding:20px 24px;margin:16px 0;">
    <p><strong>SAGA의 한계:</strong></p>
    <ol>
      <li><strong>추출 정확도</strong>: 모든 것이 State Block 파싱 품질에 달려 있습니다. LLM이 State Block을 잘못 출력하면 상태가 오염됩니다. 경량 LLM 폴백으로 완화하지만 완벽하지 않습니다.</li>
      <li><strong>1턴 지연</strong>: 상태 갱신이 비동기이므로, 갱신이 완료되기 전에 다음 턴이 시작되면 이전 상태를 참조할 수 있습니다. (asyncio.Event 락으로 순서 보장하지만, 극단적으로 빠른 입력 시 경합 가능)</li>
      <li><strong>에이전트 판단의 한계</strong>: Sub-A/B는 코드 로직이므로, 에이전트가 "이 상황에서는 다르게 판단해야 해"라고 유연하게 대응하기 어렵습니다. 코드 vs 에이전트의 트레이드오프인데, .md 캐시 구조를 잘 설계하면 코드만으로도 커버 범위가 꽤 넓어집니다.</li>
    </ol>
  </div>
</div>

<!-- ═══════════ 9. 코히바블랙님 ═══════════ -->
<hr style="border:none;height:1px;background:#d0d7de;margin:40px 0;">
<div style="margin-bottom:48px;" id="s9">
  <h2 style="font-size:22px;font-weight:800;color:#1f2328;margin-bottom:20px;padding-bottom:10px;border-bottom:2px solid #0969da;"><span style="font-family:monospace;font-size:14px;font-weight:600;color:#0969da;margin-right:6px;">09.</span> 코히바블랙님 및 선행 연구자분들께</h2>
  <p>코히바블랙님의 연구일지를 비롯한 선행 연구들에서 영감을 받아, 같은 문제를 Letta를 핵심에 두고 프록시 아키텍처로 풀어본 기록입니다. SAGA의 Curator는 Letta의 Memory Block 패턴을 직접 사용하고 있으며, 매 턴 처리를 코드 로직으로 분리하여 응답 속도를 확보하는 구조입니다.</p>
</div>

<!-- ═══════════ 10. 만들면서 느낀 것 ═══════════ -->
<hr style="border:none;height:1px;background:#d0d7de;margin:40px 0;">
<div style="margin-bottom:48px;" id="s10">
  <h2 style="font-size:22px;font-weight:800;color:#1f2328;margin-bottom:20px;padding-bottom:10px;border-bottom:2px solid #0969da;"><span style="font-family:monospace;font-size:14px;font-weight:600;color:#0969da;margin-right:6px;">10.</span> 만들면서 느낀 것</h2>
  <ol>
    <li><strong>"어디에 에이전트를 두는가"가 아키텍처의 핵심</strong>입니다. 전부 에이전트에게 맡기면 강력하지만 느리고, 전부 코드로 하면 빠르지만 경직됩니다. 에이전트의 판단력이 진짜 필요한 곳을 찾는 게 핵심이었습니다.</li>
    <li><strong>그래프 + 벡터 + KV, 셋 다 필요했습니다.</strong> 관계는 그래프, 유사도는 벡터, 상태는 KV — 각각이 다른 질문에 답합니다.</li>
    <li><strong>State Block 의존은 양날의 검</strong>입니다. 구조화된 추출이 가능하지만, LLM이 출력을 실수하면 모든 것이 무너집니다. 경량 LLM 폴백이 있지만, 근본적으로 "LLM의 출력 형식 준수"에 의존하는 건 불안 요소입니다.</li>
    <li><strong>비동기 처리가 핵심</strong>이었습니다. 유저 대기 경로에서 무거운 작업을 빼는 것만으로 체감 성능이 달라집니다.</li>
    <li><strong>직접 만들지 말고 잘 엮어라.</strong> Letta, ChromaDB, Kuzu — 각각 이미 잘 만들어진 도구입니다. SAGA의 가치는 새로운 DB나 메모리 시스템을 발명하는 게 아니라, 기존 도구들을 RP에 맞게 오케스트레이션하는 데 있습니다. Claude Code가 Bash와 grep을 조율하듯, SAGA는 그래프 DB와 벡터 DB와 Stateful Agent를 조율합니다.</li>
  </ol>
  <p>약 2주 후에 프로토타입을 공개할 예정입니다. 의견이나 제안이 있으시면 댓글로 남겨주세요. 같이 개발해 보고 싶으신 분도 편하게 연락 부탁드립니다.</p>
</div>

<!-- ═══════════ 11. 참고 자료 ═══════════ -->
<hr style="border:none;height:1px;background:#d0d7de;margin:40px 0;">
<div style="margin-bottom:48px;" id="s11">
  <h2 style="font-size:22px;font-weight:800;color:#1f2328;margin-bottom:20px;padding-bottom:10px;border-bottom:2px solid #0969da;"><span style="font-family:monospace;font-size:14px;font-weight:600;color:#0969da;margin-right:6px;">11.</span> 참고 자료</h2>
  <div style="font-size:14px;margin-bottom:10px;color:#656d76;padding-left:4px;"><span>[1]</span> 코히바블랙 (2025). <em>Letta를 이용한 장기기억 향상 및 AI 채팅 경험 향상 연구 초록.</em> <a href="https://arca.live/b/characterai/162255622" style="color:#0969da;text-decoration:none;">arca.live AI 채팅 채널</a></div>
  <div style="font-size:14px;margin-bottom:10px;color:#656d76;padding-left:4px;"><span>[2]</span> <a href="https://github.com/Shichun-Liu/Agent-Memory-Paper-List" style="color:#0969da;text-decoration:none;">Agent Memory Paper List</a> — MemGPT, Graph RAG, RAG 등 이 글에서 언급한 논문들의 종합 목록.</div>
  <div style="font-size:14px;margin-bottom:10px;color:#656d76;padding-left:4px;"><span>[3]</span> Letta (2025). <em>MemFS: Memory as a File System.</em> <a href="https://docs.letta.com/letta-code/memory" style="color:#0969da;text-decoration:none;">https://docs.letta.com/letta-code/memory</a></div>
</div>

<!-- ═══════════ 푸터 ═══════════ -->
<div style="margin-top:48px;padding-top:24px;border-top:1px solid #d0d7de;text-align:center;font-size:13px;color:#656d76;font-style:italic;">
  이 글은 <a href="https://claude.ai/claude-code" style="color:#0969da;text-decoration:none;">Claude Code</a>와 함께 작성되었습니다.
</div>

</div>
</body>
</html>
